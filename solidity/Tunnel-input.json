{"language":"Solidity","sources":{"@onchain-id/solidity/contracts/interface/IClaimIssuer.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IIdentity.sol\";\n\ninterface IClaimIssuer is IIdentity {\n\n    /**\n     * @dev Emitted when a claim is revoked.\n     *\n     * Specification: MUST be triggered when revoking a claim.\n     */\n    event ClaimRevoked(bytes indexed signature);\n\n    /**\n     * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\n     * @notice will fetch the claim from the identity contract (unsafe).\n     * @param _claimId the id of the claim\n     * @param _identity the address of the identity contract\n     * @return isRevoked true when the claim is revoked\n     */\n    function revokeClaim(bytes32 _claimId, address _identity) external returns(bool);\n\n    /**\n     * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\n     * @param signature the signature of the claim\n     */\n    function revokeClaimBySignature(bytes calldata signature) external;\n\n    /**\n     * @dev Returns revocation status of a claim.\n     * @param _sig the signature of the claim\n     * @return isRevoked true if the claim is revoked and false otherwise\n     */\n    function isClaimRevoked(bytes calldata _sig) external view returns (bool);\n\n    /**\n     * @dev Checks if a claim is valid.\n     * @param _identity the identity contract related to the claim\n     * @param claimTopic the claim topic of the claim\n     * @param sig the signature of the claim\n     * @param data the data field of the claim\n     * @return claimValid true if the claim is valid, false otherwise\n     */\n    function isClaimValid(\n        IIdentity _identity,\n        uint256 claimTopic,\n        bytes calldata sig,\n        bytes calldata data)\n    external view returns (bool);\n}\n"},"@onchain-id/solidity/contracts/interface/IERC734.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/**\n * @dev interface of the ERC734 (Key Holder) standard as defined in the EIP.\n */\ninterface IERC734 {\n\n    /**\n     * @dev Emitted when an execution request was approved.\n     *\n     * Specification: MUST be triggered when approve was successfully called.\n     */\n    event Approved(uint256 indexed executionId, bool approved);\n\n    /**\n     * @dev Emitted when an execute operation was approved and successfully performed.\n     *\n     * Specification: MUST be triggered when approve was called and the execution was successfully approved.\n     */\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n    /**\n     * @dev Emitted when an execution request was performed via `execute`.\n     *\n     * Specification: MUST be triggered when execute was successfully called.\n     */\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n    /**\n     * @dev Emitted when an execute operation was called and failed\n     *\n     * Specification: MUST be triggered when execute call failed\n     */\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n    /**\n     * @dev Emitted when a key was added to the Identity.\n     *\n     * Specification: MUST be triggered when addKey was successfully called.\n     */\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n    /**\n     * @dev Emitted when a key was removed from the Identity.\n     *\n     * Specification: MUST be triggered when removeKey was successfully called.\n     */\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n    /**\n     * @dev Adds a _key to the identity. The _purpose specifies the purpose of the key.\n     *\n     * Triggers Event: `KeyAdded`\n     *\n     * Specification: MUST only be done by keys of purpose 1, or the identity\n     * itself. If it's the identity itself, the approval process will determine its approval.\n     */\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external returns (bool success);\n\n    /**\n    * @dev Approves an execution.\n    *\n    * Triggers Event: `Approved`\n    * Triggers on execution successful Event: `Executed`\n    * Triggers on execution failure Event: `ExecutionFailed`\n    */\n    function approve(uint256 _id, bool _approve) external returns (bool success);\n\n    /**\n     * @dev Removes _purpose for _key from the identity.\n     *\n     * Triggers Event: `KeyRemoved`\n     *\n     * Specification: MUST only be done by keys of purpose 1, or the identity itself.\n     * If it's the identity itself, the approval process will determine its approval.\n     */\n    function removeKey(bytes32 _key, uint256 _purpose) external returns (bool success);\n\n    /**\n     * @dev Passes an execution instruction to an ERC734 identity.\n     * How the execution is handled is up to the identity implementation:\n     * An execution COULD be requested and require `approve` to be called with one or more keys of purpose 1 or 2 to\n     * approve this execution.\n     * Execute COULD be used as the only accessor for `addKey` and `removeKey`.\n     *\n     * Triggers Event: ExecutionRequested\n     * Triggers on direct execution Event: Executed\n     */\n    function execute(address _to, uint256 _value, bytes calldata _data) external payable returns (uint256 executionId);\n\n    /**\n     * @dev Returns the full key data, if present in the identity.\n     */\n    function getKey(bytes32 _key) external view returns (uint256[] memory purposes, uint256 keyType, bytes32 key);\n\n    /**\n     * @dev Returns the list of purposes associated with a key.\n     */\n    function getKeyPurposes(bytes32 _key) external view returns(uint256[] memory _purposes);\n\n    /**\n     * @dev Returns an array of public key bytes32 held by this identity.\n     */\n    function getKeysByPurpose(uint256 _purpose) external view returns (bytes32[] memory keys);\n\n    /**\n     * @dev Returns TRUE if a key is present and has the given purpose. If the key is not present it returns FALSE.\n     */\n    function keyHasPurpose(bytes32 _key, uint256 _purpose) external view returns (bool exists);\n}\n"},"@onchain-id/solidity/contracts/interface/IERC735.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/**\n * @dev interface of the ERC735 (Claim Holder) standard as defined in the EIP.\n */\ninterface IERC735 {\n\n    /**\n     * @dev Emitted when a claim was added.\n     *\n     * Specification: MUST be triggered when a claim was successfully added.\n     */\n    event ClaimAdded(\n        bytes32 indexed claimId,\n        uint256 indexed topic,\n        uint256 scheme,\n        address indexed issuer,\n        bytes signature,\n        bytes data,\n        string uri);\n\n    /**\n     * @dev Emitted when a claim was removed.\n     *\n     * Specification: MUST be triggered when removeClaim was successfully called.\n     */\n    event ClaimRemoved(\n        bytes32 indexed claimId,\n        uint256 indexed topic,\n        uint256 scheme,\n        address indexed issuer,\n        bytes signature,\n        bytes data,\n        string uri);\n\n    /**\n     * @dev Emitted when a claim was changed.\n     *\n     * Specification: MUST be triggered when addClaim was successfully called on an existing claimId.\n     */\n    event ClaimChanged(\n        bytes32 indexed claimId,\n        uint256 indexed topic,\n        uint256 scheme,\n        address indexed issuer,\n        bytes signature,\n        bytes data,\n        string uri);\n\n    /**\n     * @dev Add or update a claim.\n     *\n     * Triggers Event: `ClaimAdded`, `ClaimChanged`\n     *\n     * Specification: Add or update a claim from an issuer.\n     *\n     * _signature is a signed message of the following structure:\n     * `keccak256(abi.encode(address identityHolder_address, uint256 topic, bytes data))`.\n     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address + uint256 topic))`.\n     */\n    function addClaim(\n        uint256 _topic,\n        uint256 _scheme,\n        address issuer,\n        bytes calldata _signature,\n        bytes calldata _data,\n        string calldata _uri)\n    external returns (bytes32 claimRequestId);\n\n    /**\n     * @dev Removes a claim.\n     *\n     * Triggers Event: `ClaimRemoved`\n     *\n     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\n     */\n    function removeClaim(bytes32 _claimId) external returns (bool success);\n\n    /**\n     * @dev Get a claim by its ID.\n     *\n     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\n     */\n    function getClaim(bytes32 _claimId)\n    external view returns(\n        uint256 topic,\n        uint256 scheme,\n        address issuer,\n        bytes memory signature,\n        bytes memory data,\n        string memory uri);\n\n    /**\n     * @dev Returns an array of claim IDs by topic.\n     */\n    function getClaimIdsByTopic(uint256 _topic) external view returns(bytes32[] memory claimIds);\n}\n"},"@onchain-id/solidity/contracts/interface/IIdentity.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IERC734.sol\";\nimport \"./IERC735.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ninterface IIdentity is IERC734, IERC735 {\n    /**\n     * @dev Checks if a claim is valid.\n     * @param _identity the identity contract related to the claim\n     * @param claimTopic the claim topic of the claim\n     * @param sig the signature of the claim\n     * @param data the data field of the claim\n     * @return claimValid true if the claim is valid, false otherwise\n     */\n    function isClaimValid(\n        IIdentity _identity,\n        uint256 claimTopic,\n        bytes calldata sig,\n        bytes calldata data)\n    external view returns (bool);\n}\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"project:/contracts/Tunnel.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"./interfaces/IWormhole.sol\";\r\n\r\nimport \"./interfaces/IERC3643.sol\";\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\n\r\ncontract Tunnel is Context {\r\n    IWormhole private _wormhole;\r\n\r\n    uint32 private _nonce;\r\n\r\n    mapping(uint32 => bool) private _delivered;\r\n\r\n    mapping(string => address) private _evmWallet;\r\n    mapping(address => string) private _algoWallet;\r\n\r\n    mapping(uint256 => address) private _evmAsset;\r\n    mapping(address => uint256) private _algoAsset;\r\n\r\n    uint256 private GAS_LIMIT;\r\n    uint8 private CONSISTENCY_LEVEL = 200;\r\n\r\n    event AssetLocked(\r\n        address assetId,\r\n        uint256 amount,\r\n        address evmWallet,\r\n        string algoWallet,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event AssetReleased(\r\n        address assetId,\r\n        uint256 amount,\r\n        string algoWallet,\r\n        address evmWallet,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event WalletCreated(address evmWallet, string algoWallet);\r\n\r\n    event AssetCreated(address evmAssetId, uint256 algoAssetId);\r\n\r\n    event FaucetDispensed(address evmWallet, uint256 amount);\r\n\r\n    constructor(address wormhole_) {\r\n        _wormhole = IWormhole(wormhole_);\r\n    }\r\n\r\n    function faucet(address assetId, uint256 amount) external {\r\n        address evmWallet = _msgSender();\r\n\r\n        IERC3643 asset = IERC3643(assetId);\r\n        asset.transfer(evmWallet, amount);\r\n\r\n        emit FaucetDispensed(evmWallet, amount);\r\n    }\r\n\r\n    function createAsset(address evmAssetId, uint256 algoAssetId) external {\r\n        _evmAsset[algoAssetId] = evmAssetId;\r\n        _algoAsset[evmAssetId] = algoAssetId;\r\n\r\n        emit AssetCreated(evmAssetId, algoAssetId);\r\n    }\r\n\r\n    function createWallet(string memory algoWallet) external {\r\n        address evmWallet = _msgSender();\r\n\r\n        require(\r\n            bytes(_algoWallet[evmWallet]).length == 0,\r\n            \"Algo address already used\"\r\n        );\r\n\r\n        require(\r\n            _evmWallet[algoWallet] == address(0),\r\n            \"Evm wallet already used\"\r\n        );\r\n\r\n        _algoWallet[evmWallet] = algoWallet;\r\n        _evmWallet[algoWallet] = evmWallet;\r\n\r\n        emit WalletCreated(evmWallet, algoWallet);\r\n    }\r\n\r\n    /// @dev For corresponding algo wallet\r\n    function getAlgoWallet(\r\n        address evmWallet\r\n    ) external view returns (string memory) {\r\n        return _algoWallet[evmWallet];\r\n    }\r\n\r\n    /// @dev For corresponding evm wallet\r\n    function getEVMWallet(\r\n        string memory algoWallet\r\n    ) external view returns (address) {\r\n        return _evmWallet[algoWallet];\r\n    }\r\n\r\n    /// @dev For getting briging fee\r\n    function messageFee() public view returns (uint256) {\r\n        return _wormhole.messageFee();\r\n    }\r\n\r\n    /// @dev This function locks the Original NFT\r\n    /// and tell whirlExtension Contract to mint a new similar NFT\r\n    function bridge(address assetId, uint256 amount) external payable {\r\n        address evmWallet = _msgSender();\r\n\r\n        require(_algoAsset[assetId] != uint256(0), \"Algo asset not set\");\r\n        require(\r\n            bytes(_algoWallet[evmWallet]).length != 0,\r\n            \"Algo address not set\"\r\n        );\r\n\r\n        IERC3643 asset = IERC3643(assetId);\r\n        asset.transferFrom(evmWallet, address(this), amount);\r\n\r\n        bytes memory payload = abi.encode(\r\n            _algoAsset[assetId],\r\n            _algoAmount(amount),\r\n            _algoWallet[evmWallet]\r\n        );\r\n\r\n        _wormhole.publishMessage{value: messageFee()}(\r\n            _nonce,\r\n            payload,\r\n            CONSISTENCY_LEVEL\r\n        );\r\n\r\n        _nonce++;\r\n\r\n        emit AssetLocked(\r\n            assetId,\r\n            amount,\r\n            evmWallet,\r\n            _algoWallet[evmWallet],\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    // @dev This function unlocks the Original asset to the\r\n    function receiveMessage(\r\n        uint32 nonce,\r\n        uint256 algoAssetId,\r\n        uint256 amount, // in micro-algo format\r\n        string memory algoWallet\r\n    ) external {\r\n        // Ensure no duplicate deliveries\r\n        require(!_delivered[nonce], \"Message already processed\");\r\n        _delivered[nonce] = true;\r\n\r\n        require(_evmWallet[algoWallet] != address(0), \"Evm address not set\");\r\n\r\n        IERC3643 asset = IERC3643(_evmAsset[algoAssetId]);\r\n        asset.transfer(_evmWallet[algoWallet], _evmAmount(amount));\r\n\r\n        emit AssetReleased(\r\n            _evmAsset[algoAssetId],\r\n            _evmAmount(amount),\r\n            algoWallet,\r\n            _evmWallet[algoWallet],\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function _evmAmount(uint256 algoAmmount) private pure returns (uint256) {\r\n        return algoAmmount * 1_000_000_000_000;\r\n    }\r\n\r\n    function _algoAmount(uint256 evmAmount) private pure returns (uint256) {\r\n        return evmAmount / 1_000_000_000_000;\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n"},"project:/contracts/interfaces/IClaimTopicsRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\ninterface IClaimTopicsRegistry {\r\n    /**\r\n     *  this event is emitted when a claim topic has been added to the ClaimTopicsRegistry\r\n     *  the event is emitted by the 'addClaimTopic' function\r\n     *  `claimTopic` is the required claim added to the Claim Topics Registry\r\n     */\r\n    event ClaimTopicAdded(uint256 indexed claimTopic);\r\n\r\n    /**\r\n     *  this event is emitted when a claim topic has been removed from the ClaimTopicsRegistry\r\n     *  the event is emitted by the 'removeClaimTopic' function\r\n     *  `claimTopic` is the required claim removed from the Claim Topics Registry\r\n     */\r\n    event ClaimTopicRemoved(uint256 indexed claimTopic);\r\n\r\n    /**\r\n     * @dev Add a trusted claim topic (For example: KYC=1, AML=2).\r\n     * Only owner can call.\r\n     * emits `ClaimTopicAdded` event\r\n     * @param _claimTopic The claim topic index\r\n     */\r\n    function addClaimTopic(uint256 _claimTopic) external;\r\n\r\n    /**\r\n     *  @dev Remove a trusted claim topic (For example: KYC=1, AML=2).\r\n     *  Only owner can call.\r\n     *  emits `ClaimTopicRemoved` event\r\n     *  @param _claimTopic The claim topic index\r\n     */\r\n    function removeClaimTopic(uint256 _claimTopic) external;\r\n\r\n    /**\r\n     *  @dev Get the trusted claim topics for the security token\r\n     *  @return Array of trusted claim topics\r\n     */\r\n    function getClaimTopics() external view returns (uint256[] memory);\r\n\r\n    /**\r\n     *  @dev Transfers the Ownership of ClaimTopics to a new Owner.\r\n     *  Only owner can call.\r\n     *  @param _newOwner The new owner of this contract.\r\n     */\r\n    function transferOwnershipOnClaimTopicsRegistryContract(\r\n        address _newOwner\r\n    ) external;\r\n}\r\n"},"project:/contracts/interfaces/ICompliance.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\ninterface ICompliance {\r\n    /**\r\n     *  this event is emitted when the Agent has been added on the allowedList of this Compliance.\r\n     *  the event is emitted by the Compliance constructor and by the addTokenAgent function\r\n     *  `_agentAddress` is the address of the Agent to add\r\n     */\r\n    event TokenAgentAdded(address _agentAddress);\r\n\r\n    /**\r\n     *  this event is emitted when the Agent has been removed from the agent list of this Compliance.\r\n     *  the event is emitted by the Compliance constructor and by the removeTokenAgent function\r\n     *  `_agentAddress` is the address of the Agent to remove\r\n     */\r\n    event TokenAgentRemoved(address _agentAddress);\r\n\r\n    /**\r\n     *  this event is emitted when a token has been bound to the compliance contract\r\n     *  the event is emitted by the bindToken function\r\n     *  `_token` is the address of the token to bind\r\n     */\r\n    event TokenBound(address _token);\r\n\r\n    /**\r\n     *  this event is emitted when a token has been unbound from the compliance contract\r\n     *  the event is emitted by the unbindToken function\r\n     *  `_token` is the address of the token to unbind\r\n     */\r\n    event TokenUnbound(address _token);\r\n\r\n    /**\r\n     *  @dev Returns true if the Address is in the list of token agents\r\n     *  @param _agentAddress address of this agent\r\n     */\r\n    function isTokenAgent(address _agentAddress) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Returns true if the address given corresponds to a token that is bound with the Compliance contract\r\n     *  @param _token address of the token\r\n     */\r\n    function isTokenBound(address _token) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev adds an agent to the list of token agents\r\n     *  @param _agentAddress address of the agent to be added\r\n     *  Emits a TokenAgentAdded event\r\n     */\r\n    function addTokenAgent(address _agentAddress) external;\r\n\r\n    /**\r\n     *  @dev remove Agent from the list of token agents\r\n     *  @param _agentAddress address of the agent to be removed (must be added first)\r\n     *  Emits a TokenAgentRemoved event\r\n     */\r\n    function removeTokenAgent(address _agentAddress) external;\r\n\r\n    /**\r\n     *  @dev binds a token to the compliance contract\r\n     *  @param _token address of the token to bind\r\n     *  Emits a TokenBound event\r\n     */\r\n    function bindToken(address _token) external;\r\n\r\n    /**\r\n     *  @dev unbinds a token from the compliance contract\r\n     *  @param _token address of the token to unbind\r\n     *  Emits a TokenUnbound event\r\n     */\r\n    function unbindToken(address _token) external;\r\n\r\n    /**\r\n     *  @dev checks that the transfer is compliant.\r\n     *  default compliance always returns true\r\n     *  READ ONLY FUNCTION, this function cannot be used to increment\r\n     *  counters, emit events, ...\r\n     *  @param _from The address of the sender\r\n     *  @param _to The address of the receiver\r\n     *  @param _amount The amount of tokens involved in the transfer\r\n     */\r\n    function canTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev function called whenever tokens are transferred\r\n     *  from one wallet to another\r\n     *  this function can update state variables in the compliance contract\r\n     *  these state variables being used by `canTransfer` to decide if a transfer\r\n     *  is compliant or not depending on the values stored in these state variables and on\r\n     *  the parameters of the compliance smart contract\r\n     *  @param _from The address of the sender\r\n     *  @param _to The address of the receiver\r\n     *  @param _amount The amount of tokens involved in the transfer\r\n     */\r\n    function transferred(address _from, address _to, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev function called whenever tokens are created\r\n     *  on a wallet\r\n     *  this function can update state variables in the compliance contract\r\n     *  these state variables being used by `canTransfer` to decide if a transfer\r\n     *  is compliant or not depending on the values stored in these state variables and on\r\n     *  the parameters of the compliance smart contract\r\n     *  @param _to The address of the receiver\r\n     *  @param _amount The amount of tokens involved in the transfer\r\n     */\r\n    function created(address _to, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev function called whenever tokens are destroyed\r\n     *  this function can update state variables in the compliance contract\r\n     *  these state variables being used by `canTransfer` to decide if a transfer\r\n     *  is compliant or not depending on the values stored in these state variables and on\r\n     *  the parameters of the compliance smart contract\r\n     *  @param _from The address of the receiver\r\n     *  @param _amount The amount of tokens involved in the transfer\r\n     */\r\n    function destroyed(address _from, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev function used to transfer the ownership of the compliance contract\r\n     *  to a new owner, giving him access to the `OnlyOwner` functions implemented on the contract\r\n     *  @param newOwner The address of the new owner of the compliance contract\r\n     *  This function can only be called by the owner of the compliance contract\r\n     *  emits an `OwnershipTransferred` event\r\n     */\r\n    function transferOwnershipOnComplianceContract(address newOwner) external;\r\n}\r\n"},"project:/contracts/interfaces/IERC3643.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./IIdentityRegistry.sol\";\r\nimport \"./ICompliance.sol\";\r\n\r\n///interface\r\ninterface IERC3643 is IERC20 {\r\n    /**\r\n     *  this event is emitted when the token information is updated.\r\n     *  the event is emitted by the token constructor and by the setTokenInformation function\r\n     *  `_newName` is the name of the token\r\n     *  `_newSymbol` is the symbol of the token\r\n     *  `_newDecimals` is the decimals of the token\r\n     *  `_newVersion` is the version of the token, current version is 3.0\r\n     *  `_newOnchainID` is the address of the onchainID of the token\r\n     */\r\n    event UpdatedTokenInformation(\r\n        string _newName,\r\n        string _newSymbol,\r\n        uint8 _newDecimals,\r\n        string _newVersion,\r\n        address _newOnchainID\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when the IdentityRegistry has been set for the token\r\n     *  the event is emitted by the token constructor and by the setIdentityRegistry function\r\n     *  `_identityRegistry` is the address of the Identity Registry of the token\r\n     */\r\n    event IdentityRegistryAdded(address indexed _identityRegistry);\r\n\r\n    /**\r\n     *  this event is emitted when the Compliance has been set for the token\r\n     *  the event is emitted by the token constructor and by the setCompliance function\r\n     *  `_compliance` is the address of the Compliance contract of the token\r\n     */\r\n    event ComplianceAdded(address indexed _compliance);\r\n\r\n    /**\r\n     *  this event is emitted when an investor successfully recovers his tokens\r\n     *  the event is emitted by the recoveryAddress function\r\n     *  `_lostWallet` is the address of the wallet that the investor lost access to\r\n     *  `_newWallet` is the address of the wallet that the investor provided for the recovery\r\n     *  `_investorOnchainID` is the address of the onchainID of the investor who asked for a recovery\r\n     */\r\n    event RecoverySuccess(\r\n        address _lostWallet,\r\n        address _newWallet,\r\n        address _investorOnchainID\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when the wallet of an investor is frozen or unfrozen\r\n     *  the event is emitted by setAddressFrozen and batchSetAddressFrozen functions\r\n     *  `_userAddress` is the wallet of the investor that is concerned by the freezing status\r\n     *  `_isFrozen` is the freezing status of the wallet\r\n     *  if `_isFrozen` equals `true` the wallet is frozen after emission of the event\r\n     *  if `_isFrozen` equals `false` the wallet is unfrozen after emission of the event\r\n     *  `_owner` is the address of the agent who called the function to freeze the wallet\r\n     */\r\n    event AddressFrozen(\r\n        address indexed _userAddress,\r\n        bool indexed _isFrozen,\r\n        address indexed _owner\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when a certain amount of tokens is frozen on a wallet\r\n     *  the event is emitted by freezePartialTokens and batchFreezePartialTokens functions\r\n     *  `_userAddress` is the wallet of the investor that is concerned by the freezing status\r\n     *  `_amount` is the amount of tokens that are frozen\r\n     */\r\n    event TokensFrozen(address indexed _userAddress, uint256 _amount);\r\n\r\n    /**\r\n     *  this event is emitted when a certain amount of tokens is unfrozen on a wallet\r\n     *  the event is emitted by unfreezePartialTokens and batchUnfreezePartialTokens functions\r\n     *  `_userAddress` is the wallet of the investor that is concerned by the freezing status\r\n     *  `_amount` is the amount of tokens that are unfrozen\r\n     */\r\n    event TokensUnfrozen(address indexed _userAddress, uint256 _amount);\r\n\r\n    /**\r\n     *  this event is emitted when the token is paused\r\n     *  the event is emitted by the pause function\r\n     *  `_userAddress` is the address of the wallet that called the pause function\r\n     */\r\n    event Paused(address _userAddress);\r\n\r\n    /**\r\n     *  this event is emitted when the token is unpaused\r\n     *  the event is emitted by the unpause function\r\n     *  `_userAddress` is the address of the wallet that called the unpause function\r\n     */\r\n    event Unpaused(address _userAddress);\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 1 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * balanceOf() and transfer().\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the address of the onchainID of the token.\r\n     * the onchainID of the token gives all the information available\r\n     * about the token and is managed by the token issuer or his agent.\r\n     */\r\n    function onchainID() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the TREX version of the token.\r\n     * current version is 3.0.0\r\n     */\r\n    function version() external view returns (string memory);\r\n\r\n    /**\r\n     *  @dev Returns the Identity Registry linked to the token\r\n     */\r\n    function identityRegistry() external view returns (IIdentityRegistry);\r\n\r\n    /**\r\n     *  @dev Returns the Compliance contract linked to the token\r\n     */\r\n    function compliance() external view returns (ICompliance);\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Returns the freezing status of a wallet\r\n     *  if isFrozen returns `true` the wallet is frozen\r\n     *  if isFrozen returns `false` the wallet is not frozen\r\n     *  isFrozen returning `true` doesn't mean that the balance is free, tokens could be blocked by\r\n     *  a partial freeze or the whole token could be blocked by pause\r\n     *  @param _userAddress the address of the wallet on which isFrozen is called\r\n     */\r\n    function isFrozen(address _userAddress) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Returns the amount of tokens that are partially frozen on a wallet\r\n     *  the amount of frozen tokens is always <= to the total balance of the wallet\r\n     *  @param _userAddress the address of the wallet on which getFrozenTokens is called\r\n     */\r\n    function getFrozenTokens(\r\n        address _userAddress\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     *  @dev sets the token name\r\n     *  @param _name the name of token to set\r\n     *  Only the owner of the token smart contract can call this function\r\n     *  emits a `UpdatedTokenInformation` event\r\n     */\r\n    function setName(string calldata _name) external;\r\n\r\n    /**\r\n     *  @dev sets the token symbol\r\n     *  @param _symbol the token symbol to set\r\n     *  Only the owner of the token smart contract can call this function\r\n     *  emits a `UpdatedTokenInformation` event\r\n     */\r\n    function setSymbol(string calldata _symbol) external;\r\n\r\n    /**\r\n     *  @dev sets the onchain ID of the token\r\n     *  @param _onchainID the address of the onchain ID to set\r\n     *  Only the owner of the token smart contract can call this function\r\n     *  emits a `UpdatedTokenInformation` event\r\n     */\r\n    function setOnchainID(address _onchainID) external;\r\n\r\n    /**\r\n     *  @dev pauses the token contract, when contract is paused investors cannot transfer tokens anymore\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `Paused` event\r\n     */\r\n    function pause() external;\r\n\r\n    /**\r\n     *  @dev unpauses the token contract, when contract is unpaused investors can transfer tokens\r\n     *  if their wallet is not blocked & if the amount to transfer is <= to the amount of free tokens\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits an `Unpaused` event\r\n     */\r\n    function unpause() external;\r\n\r\n    /**\r\n     *  @dev sets an address frozen status for this token.\r\n     *  @param _userAddress The address for which to update frozen status\r\n     *  @param _freeze Frozen status of the address\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits an `AddressFrozen` event\r\n     */\r\n    function setAddressFrozen(address _userAddress, bool _freeze) external;\r\n\r\n    /**\r\n     *  @dev freezes token amount specified for given address.\r\n     *  @param _userAddress The address for which to update frozen tokens\r\n     *  @param _amount Amount of Tokens to be frozen\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `TokensFrozen` event\r\n     */\r\n    function freezePartialTokens(\r\n        address _userAddress,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev unfreezes token amount specified for given address\r\n     *  @param _userAddress The address for which to update frozen tokens\r\n     *  @param _amount Amount of Tokens to be unfrozen\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `TokensUnfrozen` event\r\n     */\r\n    function unfreezePartialTokens(\r\n        address _userAddress,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev sets the Identity Registry for the token\r\n     *  @param _identityRegistry the address of the Identity Registry to set\r\n     *  Only the owner of the token smart contract can call this function\r\n     *  emits an `IdentityRegistryAdded` event\r\n     */\r\n    function setIdentityRegistry(address _identityRegistry) external;\r\n\r\n    /**\r\n     *  @dev sets the compliance contract of the token\r\n     *  @param _compliance the address of the compliance contract to set\r\n     *  Only the owner of the token smart contract can call this function\r\n     *  emits a `ComplianceAdded` event\r\n     */\r\n    function setCompliance(address _compliance) external;\r\n\r\n    /**\r\n     *  @dev force a transfer of tokens between 2 whitelisted wallets\r\n     *  In case the `from` address has not enough free tokens (unfrozen tokens)\r\n     *  but has a total balance higher or equal to the `amount`\r\n     *  the amount of frozen tokens is reduced in order to have enough free tokens\r\n     *  to proceed the transfer, in such a case, the remaining balance on the `from`\r\n     *  account is 100% composed of frozen tokens post-transfer.\r\n     *  Require that the `to` address is a verified address,\r\n     *  @param _from The address of the sender\r\n     *  @param _to The address of the receiver\r\n     *  @param _amount The number of tokens to transfer\r\n     *  @return `true` if successful and revert if unsuccessful\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `TokensUnfrozen` event if `_amount` is higher than the free balance of `_from`\r\n     *  emits a `Transfer` event\r\n     */\r\n    function forcedTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     *  @dev mint tokens on a wallet\r\n     *  Improved version of default mint method. Tokens can be minted\r\n     *  to an address if only it is a verified address as per the security token.\r\n     *  @param _to Address to mint the tokens to.\r\n     *  @param _amount Amount of tokens to mint.\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `Transfer` event\r\n     */\r\n    function mint(address _to, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev burn tokens on a wallet\r\n     *  In case the `account` address has not enough free tokens (unfrozen tokens)\r\n     *  but has a total balance higher or equal to the `value` amount\r\n     *  the amount of frozen tokens is reduced in order to have enough free tokens\r\n     *  to proceed the burn, in such a case, the remaining balance on the `account`\r\n     *  is 100% composed of frozen tokens post-transaction.\r\n     *  @param _userAddress Address to burn the tokens from.\r\n     *  @param _amount Amount of tokens to burn.\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `TokensUnfrozen` event if `_amount` is higher than the free balance of `_userAddress`\r\n     *  emits a `Transfer` event\r\n     */\r\n    function burn(address _userAddress, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev recovery function used to force transfer tokens from a\r\n     *  lost wallet to a new wallet for an investor.\r\n     *  @param _lostWallet the wallet that the investor lost\r\n     *  @param _newWallet the newly provided wallet on which tokens have to be transferred\r\n     *  @param _investorOnchainID the onchainID of the investor asking for a recovery\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `TokensUnfrozen` event if there is some frozen tokens on the lost wallet if the recovery process is successful\r\n     *  emits a `Transfer` event if the recovery process is successful\r\n     *  emits a `RecoverySuccess` event if the recovery process is successful\r\n     *  emits a `RecoveryFails` event if the recovery process fails\r\n     */\r\n    function recoveryAddress(\r\n        address _lostWallet,\r\n        address _newWallet,\r\n        address _investorOnchainID\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     *  @dev function allowing to issue transfers in batch\r\n     *  Require that the msg.sender and `to` addresses are not frozen.\r\n     *  Require that the total value should not exceed available balance.\r\n     *  Require that the `to` addresses are all verified addresses,\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_toList.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _toList The addresses of the receivers\r\n     *  @param _amounts The number of tokens to transfer to the corresponding receiver\r\n     *  emits _toList.length `Transfer` events\r\n     */\r\n    function batchTransfer(\r\n        address[] calldata _toList,\r\n        uint256[] calldata _amounts\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev function allowing to issue forced transfers in batch\r\n     *  Require that `_amounts[i]` should not exceed available balance of `_fromList[i]`.\r\n     *  Require that the `_toList` addresses are all verified addresses\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_fromList.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _fromList The addresses of the senders\r\n     *  @param _toList The addresses of the receivers\r\n     *  @param _amounts The number of tokens to transfer to the corresponding receiver\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits `TokensUnfrozen` events if `_amounts[i]` is higher than the free balance of `_fromList[i]`\r\n     *  emits _fromList.length `Transfer` events\r\n     */\r\n    function batchForcedTransfer(\r\n        address[] calldata _fromList,\r\n        address[] calldata _toList,\r\n        uint256[] calldata _amounts\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev function allowing to mint tokens in batch\r\n     *  Require that the `_toList` addresses are all verified addresses\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_toList.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _toList The addresses of the receivers\r\n     *  @param _amounts The number of tokens to mint to the corresponding receiver\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits _toList.length `Transfer` events\r\n     */\r\n    function batchMint(\r\n        address[] calldata _toList,\r\n        uint256[] calldata _amounts\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev function allowing to burn tokens in batch\r\n     *  Require that the `_userAddresses` addresses are all verified addresses\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses of the wallets concerned by the burn\r\n     *  @param _amounts The number of tokens to burn from the corresponding wallets\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits _userAddresses.length `Transfer` events\r\n     */\r\n    function batchBurn(\r\n        address[] calldata _userAddresses,\r\n        uint256[] calldata _amounts\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev function allowing to set frozen addresses in batch\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses for which to update frozen status\r\n     *  @param _freeze Frozen status of the corresponding address\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits _userAddresses.length `AddressFrozen` events\r\n     */\r\n    function batchSetAddressFrozen(\r\n        address[] calldata _userAddresses,\r\n        bool[] calldata _freeze\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev function allowing to freeze tokens partially in batch\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses on which tokens need to be frozen\r\n     *  @param _amounts the amount of tokens to freeze on the corresponding address\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits _userAddresses.length `TokensFrozen` events\r\n     */\r\n    function batchFreezePartialTokens(\r\n        address[] calldata _userAddresses,\r\n        uint256[] calldata _amounts\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev function allowing to unfreeze tokens partially in batch\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses on which tokens need to be unfrozen\r\n     *  @param _amounts the amount of tokens to unfreeze on the corresponding address\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits _userAddresses.length `TokensUnfrozen` events\r\n     */\r\n    function batchUnfreezePartialTokens(\r\n        address[] calldata _userAddresses,\r\n        uint256[] calldata _amounts\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev transfers the ownership of the token smart contract\r\n     *  @param _newOwner the address of the new token smart contract owner\r\n     *  This function can only be called by the owner of the token\r\n     *  emits an `OwnershipTransferred` event\r\n     */\r\n    function transferOwnershipOnTokenContract(address _newOwner) external;\r\n\r\n    /**\r\n     *  @dev adds an agent to the token smart contract\r\n     *  @param _agent the address of the new agent of the token smart contract\r\n     *  This function can only be called by the owner of the token\r\n     *  emits an `AgentAdded` event\r\n     */\r\n    function addAgentOnTokenContract(address _agent) external;\r\n\r\n    /**\r\n     *  @dev remove an agent from the token smart contract\r\n     *  @param _agent the address of the agent to remove\r\n     *  This function can only be called by the owner of the token\r\n     *  emits an `AgentRemoved` event\r\n     */\r\n    function removeAgentOnTokenContract(address _agent) external;\r\n}\r\n"},"project:/contracts/interfaces/IIdentityRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"./ITrustedIssuersRegistry.sol\";\r\nimport \"./IClaimTopicsRegistry.sol\";\r\nimport \"./IIdentityRegistryStorage.sol\";\r\n\r\nimport \"@onchain-id/solidity/contracts/interface/IClaimIssuer.sol\";\r\nimport \"@onchain-id/solidity/contracts/interface/IIdentity.sol\";\r\n\r\ninterface IIdentityRegistry {\r\n    /**\r\n     *  this event is emitted when the ClaimTopicsRegistry has been set for the IdentityRegistry\r\n     *  the event is emitted by the IdentityRegistry constructor\r\n     *  `claimTopicsRegistry` is the address of the Claim Topics Registry contract\r\n     */\r\n    event ClaimTopicsRegistrySet(address indexed claimTopicsRegistry);\r\n\r\n    /**\r\n     *  this event is emitted when the IdentityRegistryStorage has been set for the IdentityRegistry\r\n     *  the event is emitted by the IdentityRegistry constructor\r\n     *  `identityStorage` is the address of the Identity Registry Storage contract\r\n     */\r\n    event IdentityStorageSet(address indexed identityStorage);\r\n\r\n    /**\r\n     *  this event is emitted when the ClaimTopicsRegistry has been set for the IdentityRegistry\r\n     *  the event is emitted by the IdentityRegistry constructor\r\n     *  `trustedIssuersRegistry` is the address of the Trusted Issuers Registry contract\r\n     */\r\n    event TrustedIssuersRegistrySet(address indexed trustedIssuersRegistry);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity is registered into the Identity Registry.\r\n     *  the event is emitted by the 'registerIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityRegistered(\r\n        address indexed investorAddress,\r\n        IIdentity indexed identity\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when an Identity is removed from the Identity Registry.\r\n     *  the event is emitted by the 'deleteIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityRemoved(\r\n        address indexed investorAddress,\r\n        IIdentity indexed identity\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when an Identity has been updated\r\n     *  the event is emitted by the 'updateIdentity' function\r\n     *  `oldIdentity` is the old Identity contract's address to update\r\n     *  `newIdentity` is the new Identity contract's\r\n     */\r\n    event IdentityUpdated(\r\n        IIdentity indexed oldIdentity,\r\n        IIdentity indexed newIdentity\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when an Identity's country has been updated\r\n     *  the event is emitted by the 'updateCountry' function\r\n     *  `investorAddress` is the address on which the country has been updated\r\n     *  `country` is the numeric code (ISO 3166-1) of the new country\r\n     */\r\n    event CountryUpdated(\r\n        address indexed investorAddress,\r\n        uint16 indexed country\r\n    );\r\n\r\n    /**\r\n     *  @dev Register an identity contract corresponding to a user address.\r\n     *  Requires that the user doesn't have an identity contract already registered.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's identity contract\r\n     *  @param _country The country of the investor\r\n     *  emits `IdentityRegistered` event\r\n     */\r\n    function registerIdentity(\r\n        address _userAddress,\r\n        IIdentity _identity,\r\n        uint16 _country\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Removes an user from the identity registry.\r\n     *  Requires that the user have an identity contract already deployed that will be deleted.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user to be removed\r\n     *  emits `IdentityRemoved` event\r\n     */\r\n    function deleteIdentity(address _userAddress) external;\r\n\r\n    /**\r\n     *  @dev Replace the actual identityRegistryStorage contract with a new one.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _identityRegistryStorage The address of the new Identity Registry Storage\r\n     *  emits `IdentityStorageSet` event\r\n     */\r\n    function setIdentityRegistryStorage(\r\n        address _identityRegistryStorage\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Replace the actual claimTopicsRegistry contract with a new one.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _claimTopicsRegistry The address of the new claim Topics Registry\r\n     *  emits `ClaimTopicsRegistrySet` event\r\n     */\r\n    function setClaimTopicsRegistry(address _claimTopicsRegistry) external;\r\n\r\n    /**\r\n     *  @dev Replace the actual trustedIssuersRegistry contract with a new one.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _trustedIssuersRegistry The address of the new Trusted Issuers Registry\r\n     *  emits `TrustedIssuersRegistrySet` event\r\n     */\r\n    function setTrustedIssuersRegistry(\r\n        address _trustedIssuersRegistry\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Updates the country corresponding to a user address.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _country The new country of the user\r\n     *  emits `CountryUpdated` event\r\n     */\r\n    function updateCountry(address _userAddress, uint16 _country) external;\r\n\r\n    /**\r\n     *  @dev Updates an identity contract corresponding to a user address.\r\n     *  Requires that the user address should be the owner of the identity contract.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's new identity contract\r\n     *  emits `IdentityUpdated` event\r\n     */\r\n    function updateIdentity(address _userAddress, IIdentity _identity) external;\r\n\r\n    /**\r\n     *  @dev function allowing to register identities in batch\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  Requires that none of the users has an identity contract already registered.\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses of the users\r\n     *  @param _identities The addresses of the corresponding identity contracts\r\n     *  @param _countries The countries of the corresponding investors\r\n     *  emits _userAddresses.length `IdentityRegistered` events\r\n     */\r\n    function batchRegisterIdentity(\r\n        address[] calldata _userAddresses,\r\n        IIdentity[] calldata _identities,\r\n        uint16[] calldata _countries\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev This functions checks whether a wallet has its Identity registered or not\r\n     *  in the Identity Registry.\r\n     *  @param _userAddress The address of the user to be checked.\r\n     *  @return 'True' if the address is contained in the Identity Registry, 'false' if not.\r\n     */\r\n    function contains(address _userAddress) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev This functions checks whether an identity contract\r\n     *  corresponding to the provided user address has the required claims or not based\r\n     *  on the data fetched from trusted issuers registry and from the claim topics registry\r\n     *  @param _userAddress The address of the user to be verified.\r\n     *  @return 'True' if the address is verified, 'false' if not.\r\n     */\r\n    function isVerified(address _userAddress) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Returns the onchainID of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function identity(address _userAddress) external view returns (IIdentity);\r\n\r\n    /**\r\n     *  @dev Returns the country code of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function investorCountry(\r\n        address _userAddress\r\n    ) external view returns (uint16);\r\n\r\n    /**\r\n     *  @dev Returns the IdentityRegistryStorage linked to the current IdentityRegistry.\r\n     */\r\n    function identityStorage() external view returns (IIdentityRegistryStorage);\r\n\r\n    /**\r\n     *  @dev Returns the TrustedIssuersRegistry linked to the current IdentityRegistry.\r\n     */\r\n    function issuersRegistry() external view returns (ITrustedIssuersRegistry);\r\n\r\n    /**\r\n     *  @dev Returns the ClaimTopicsRegistry linked to the current IdentityRegistry.\r\n     */\r\n    function topicsRegistry() external view returns (IClaimTopicsRegistry);\r\n\r\n    /**\r\n     *  @notice Transfers the Ownership of the Identity Registry to a new Owner.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _newOwner The new owner of this contract.\r\n     */\r\n    function transferOwnershipOnIdentityRegistryContract(\r\n        address _newOwner\r\n    ) external;\r\n\r\n    /**\r\n     *  @notice Adds an address as _agent of the Identity Registry Contract.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _agent The _agent's address to add.\r\n     */\r\n    function addAgentOnIdentityRegistryContract(address _agent) external;\r\n\r\n    /**\r\n     *  @notice Removes an address from being _agent of the Identity Registry Contract.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _agent The _agent's address to remove.\r\n     */\r\n    function removeAgentOnIdentityRegistryContract(address _agent) external;\r\n}\r\n"},"project:/contracts/interfaces/IIdentityRegistryStorage.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@onchain-id/solidity/contracts/interface/IIdentity.sol\";\r\n\r\ninterface IIdentityRegistryStorage {\r\n    //events\r\n    /**\r\n     *  this event is emitted when an Identity is registered into the storage contract.\r\n     *  the event is emitted by the 'registerIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityStored(\r\n        address indexed investorAddress,\r\n        IIdentity indexed identity\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when an Identity is removed from the storage contract.\r\n     *  the event is emitted by the 'deleteIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityUnstored(\r\n        address indexed investorAddress,\r\n        IIdentity indexed identity\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when an Identity has been updated\r\n     *  the event is emitted by the 'updateIdentity' function\r\n     *  `oldIdentity` is the old Identity contract's address to update\r\n     *  `newIdentity` is the new Identity contract's\r\n     */\r\n    event IdentityModified(\r\n        IIdentity indexed oldIdentity,\r\n        IIdentity indexed newIdentity\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when an Identity's country has been updated\r\n     *  the event is emitted by the 'updateCountry' function\r\n     *  `investorAddress` is the address on which the country has been updated\r\n     *  `country` is the numeric code (ISO 3166-1) of the new country\r\n     */\r\n    event CountryModified(\r\n        address indexed investorAddress,\r\n        uint16 indexed country\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when an Identity Registry is bound to the storage contract\r\n     *  the event is emitted by the 'addIdentityRegistry' function\r\n     *  `identityRegistry` is the address of the identity registry added\r\n     */\r\n    event IdentityRegistryBound(address indexed identityRegistry);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity Registry is unbound from the storage contract\r\n     *  the event is emitted by the 'removeIdentityRegistry' function\r\n     *  `identityRegistry` is the address of the identity registry removed\r\n     */\r\n    event IdentityRegistryUnbound(address indexed identityRegistry);\r\n\r\n    //functions\r\n    /**\r\n     *  @dev Returns the identity registries linked to the storage contract\r\n     */\r\n    function linkedIdentityRegistries()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /**\r\n     *  @dev Returns the onchainID of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function storedIdentity(\r\n        address _userAddress\r\n    ) external view returns (IIdentity);\r\n\r\n    /**\r\n     *  @dev Returns the country code of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function storedInvestorCountry(\r\n        address _userAddress\r\n    ) external view returns (uint16);\r\n\r\n    /**\r\n     *  @dev adds an identity contract corresponding to a user address in the storage.\r\n     *  Requires that the user doesn't have an identity contract already registered.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's identity contract\r\n     *  @param _country The country of the investor\r\n     *  emits `IdentityStored` event\r\n     */\r\n    function addIdentityToStorage(\r\n        address _userAddress,\r\n        IIdentity _identity,\r\n        uint16 _country\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Removes an user from the storage.\r\n     *  Requires that the user have an identity contract already deployed that will be deleted.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user to be removed\r\n     *  emits `IdentityUnstored` event\r\n     */\r\n    function removeIdentityFromStorage(address _userAddress) external;\r\n\r\n    /**\r\n     *  @dev Updates the country corresponding to a user address.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _country The new country of the user\r\n     *  emits `CountryModified` event\r\n     */\r\n    function modifyStoredInvestorCountry(\r\n        address _userAddress,\r\n        uint16 _country\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Updates an identity contract corresponding to a user address.\r\n     *  Requires that the user address should be the owner of the identity contract.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's new identity contract\r\n     *  emits `IdentityModified` event\r\n     */\r\n    function modifyStoredIdentity(\r\n        address _userAddress,\r\n        IIdentity _identity\r\n    ) external;\r\n\r\n    /**\r\n     *  @notice Adds an identity registry as agent of the Identity Registry Storage Contract.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  This function adds the identity registry to the list of identityRegistries linked to the storage contract\r\n     *  @param _identityRegistry The identity registry address to add.\r\n     */\r\n    function bindIdentityRegistry(address _identityRegistry) external;\r\n\r\n    /**\r\n     *  @notice Removes an identity registry from being agent of the Identity Registry Storage Contract.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  This function removes the identity registry from the list of identityRegistries linked to the storage contract\r\n     *  @param _identityRegistry The identity registry address to remove.\r\n     */\r\n    function unbindIdentityRegistry(address _identityRegistry) external;\r\n\r\n    /**\r\n     *  @notice Transfers the Ownership of the Identity Registry Storage to a new Owner.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _newOwner The new owner of this contract.\r\n     */\r\n    function transferOwnershipOnIdentityRegistryStorage(\r\n        address _newOwner\r\n    ) external;\r\n}\r\n"},"project:/contracts/interfaces/ITrustedIssuersRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@onchain-id/solidity/contracts/interface/IClaimIssuer.sol\";\r\n\r\ninterface ITrustedIssuersRegistry {\r\n    /**\r\n     *  this event is emitted when a trusted issuer is added in the registry.\r\n     *  the event is emitted by the addTrustedIssuer function\r\n     *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract\r\n     *  `claimTopics` is the set of claims that the trusted issuer is allowed to emit\r\n     */\r\n    event TrustedIssuerAdded(\r\n        IClaimIssuer indexed trustedIssuer,\r\n        uint[] claimTopics\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when a trusted issuer is removed from the registry.\r\n     *  the event is emitted by the removeTrustedIssuer function\r\n     *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract\r\n     */\r\n    event TrustedIssuerRemoved(IClaimIssuer indexed trustedIssuer);\r\n\r\n    /**\r\n     *  this event is emitted when the set of claim topics is changed for a given trusted issuer.\r\n     *  the event is emitted by the updateIssuerClaimTopics function\r\n     *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract\r\n     *  `claimTopics` is the set of claims that the trusted issuer is allowed to emit\r\n     */\r\n    event ClaimTopicsUpdated(\r\n        IClaimIssuer indexed trustedIssuer,\r\n        uint[] claimTopics\r\n    );\r\n\r\n    /**\r\n     *  @dev registers a ClaimIssuer contract as trusted claim issuer.\r\n     *  Requires that a ClaimIssuer contract doesn't already exist\r\n     *  Requires that the claimTopics set is not empty\r\n     *  @param _trustedIssuer The ClaimIssuer contract address of the trusted claim issuer.\r\n     *  @param _claimTopics the set of claim topics that the trusted issuer is allowed to emit\r\n     *  This function can only be called by the owner of the Trusted Issuers Registry contract\r\n     *  emits a `TrustedIssuerAdded` event\r\n     */\r\n    function addTrustedIssuer(\r\n        IClaimIssuer _trustedIssuer,\r\n        uint[] calldata _claimTopics\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Removes the ClaimIssuer contract of a trusted claim issuer.\r\n     *  Requires that the claim issuer contract to be registered first\r\n     *  @param _trustedIssuer the claim issuer to remove.\r\n     *  This function can only be called by the owner of the Trusted Issuers Registry contract\r\n     *  emits a `TrustedIssuerRemoved` event\r\n     */\r\n    function removeTrustedIssuer(IClaimIssuer _trustedIssuer) external;\r\n\r\n    /**\r\n     *  @dev Updates the set of claim topics that a trusted issuer is allowed to emit.\r\n     *  Requires that this ClaimIssuer contract already exists in the registry\r\n     *  Requires that the provided claimTopics set is not empty\r\n     *  @param _trustedIssuer the claim issuer to update.\r\n     *  @param _claimTopics the set of claim topics that the trusted issuer is allowed to emit\r\n     *  This function can only be called by the owner of the Trusted Issuers Registry contract\r\n     *  emits a `ClaimTopicsUpdated` event\r\n     */\r\n    function updateIssuerClaimTopics(\r\n        IClaimIssuer _trustedIssuer,\r\n        uint[] calldata _claimTopics\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Function for getting all the trusted claim issuers stored.\r\n     *  @return array of all claim issuers registered.\r\n     */\r\n    function getTrustedIssuers() external view returns (IClaimIssuer[] memory);\r\n\r\n    /**\r\n     *  @dev Checks if the ClaimIssuer contract is trusted\r\n     *  @param _issuer the address of the ClaimIssuer contract\r\n     *  @return true if the issuer is trusted, false otherwise.\r\n     */\r\n    function isTrustedIssuer(address _issuer) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Function for getting all the claim topic of trusted claim issuer\r\n     *  Requires the provided ClaimIssuer contract to be registered in the trusted issuers registry.\r\n     *  @param _trustedIssuer the trusted issuer concerned.\r\n     *  @return The set of claim topics that the trusted issuer is allowed to emit\r\n     */\r\n    function getTrustedIssuerClaimTopics(\r\n        IClaimIssuer _trustedIssuer\r\n    ) external view returns (uint[] memory);\r\n\r\n    /**\r\n     *  @dev Function for checking if the trusted claim issuer is allowed\r\n     *  to emit a certain claim topic\r\n     *  @param _issuer the address of the trusted issuer's ClaimIssuer contract\r\n     *  @param _claimTopic the Claim Topic that has to be checked to know if the `issuer` is allowed to emit it\r\n     *  @return true if the issuer is trusted for this claim topic.\r\n     */\r\n    function hasClaimTopic(\r\n        address _issuer,\r\n        uint _claimTopic\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Transfers the Ownership of TrustedIssuersRegistry to a new Owner.\r\n     *  @param _newOwner The new owner of this contract.\r\n     *  This function can only be called by the owner of the Trusted Issuers Registry contract\r\n     *  emits an `OwnershipTransferred` event\r\n     */\r\n    function transferOwnershipOnIssuersRegistryContract(\r\n        address _newOwner\r\n    ) external;\r\n}\r\n"},"project:/contracts/interfaces/IWormhole.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\ninterface IWormhole {\r\n    struct GuardianSet {\r\n        address[] keys;\r\n        uint32 expirationTime;\r\n    }\r\n\r\n    struct Signature {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        uint8 guardianIndex;\r\n    }\r\n\r\n    struct VM {\r\n        uint8 version;\r\n        uint32 timestamp;\r\n        uint32 nonce;\r\n        uint16 emitterChainId;\r\n        bytes32 emitterAddress;\r\n        uint64 sequence;\r\n        uint8 consistencyLevel;\r\n        bytes payload;\r\n        uint32 guardianSetIndex;\r\n        Signature[] signatures;\r\n        bytes32 hash;\r\n    }\r\n\r\n    struct ContractUpgrade {\r\n        bytes32 module;\r\n        uint8 action;\r\n        uint16 chain;\r\n        address newContract;\r\n    }\r\n\r\n    struct GuardianSetUpgrade {\r\n        bytes32 module;\r\n        uint8 action;\r\n        uint16 chain;\r\n        GuardianSet newGuardianSet;\r\n        uint32 newGuardianSetIndex;\r\n    }\r\n\r\n    struct SetMessageFee {\r\n        bytes32 module;\r\n        uint8 action;\r\n        uint16 chain;\r\n        uint256 messageFee;\r\n    }\r\n\r\n    struct TransferFees {\r\n        bytes32 module;\r\n        uint8 action;\r\n        uint16 chain;\r\n        uint256 amount;\r\n        bytes32 recipient;\r\n    }\r\n\r\n    struct RecoverChainId {\r\n        bytes32 module;\r\n        uint8 action;\r\n        uint256 evmChainId;\r\n        uint16 newChainId;\r\n    }\r\n\r\n    event LogMessagePublished(\r\n        address indexed sender,\r\n        uint64 sequence,\r\n        uint32 nonce,\r\n        bytes payload,\r\n        uint8 consistencyLevel\r\n    );\r\n    event ContractUpgraded(\r\n        address indexed oldContract,\r\n        address indexed newContract\r\n    );\r\n    event GuardianSetAdded(uint32 indexed index);\r\n\r\n    function publishMessage(\r\n        uint32 nonce,\r\n        bytes memory payload,\r\n        uint8 consistencyLevel\r\n    ) external payable returns (uint64 sequence);\r\n\r\n    function initialize() external;\r\n\r\n    function parseAndVerifyVM(\r\n        bytes calldata encodedVM\r\n    ) external view returns (VM memory vm, bool valid, string memory reason);\r\n\r\n    function verifyVM(\r\n        VM memory vm\r\n    ) external view returns (bool valid, string memory reason);\r\n\r\n    function verifySignatures(\r\n        bytes32 hash,\r\n        Signature[] memory signatures,\r\n        GuardianSet memory guardianSet\r\n    ) external pure returns (bool valid, string memory reason);\r\n\r\n    function parseVM(\r\n        bytes memory encodedVM\r\n    ) external pure returns (VM memory vm);\r\n\r\n    function quorum(\r\n        uint numGuardians\r\n    ) external pure returns (uint numSignaturesRequiredForQuorum);\r\n\r\n    function getGuardianSet(\r\n        uint32 index\r\n    ) external view returns (GuardianSet memory);\r\n\r\n    function getCurrentGuardianSetIndex() external view returns (uint32);\r\n\r\n    function getGuardianSetExpiry() external view returns (uint32);\r\n\r\n    function governanceActionIsConsumed(\r\n        bytes32 hash\r\n    ) external view returns (bool);\r\n\r\n    function isInitialized(address impl) external view returns (bool);\r\n\r\n    function chainId() external view returns (uint16);\r\n\r\n    function isFork() external view returns (bool);\r\n\r\n    function governanceChainId() external view returns (uint16);\r\n\r\n    function governanceContract() external view returns (bytes32);\r\n\r\n    function messageFee() external view returns (uint256);\r\n\r\n    function evmChainId() external view returns (uint256);\r\n\r\n    function nextSequence(address emitter) external view returns (uint64);\r\n\r\n    function parseContractUpgrade(\r\n        bytes memory encodedUpgrade\r\n    ) external pure returns (ContractUpgrade memory cu);\r\n\r\n    function parseGuardianSetUpgrade(\r\n        bytes memory encodedUpgrade\r\n    ) external pure returns (GuardianSetUpgrade memory gsu);\r\n\r\n    function parseSetMessageFee(\r\n        bytes memory encodedSetMessageFee\r\n    ) external pure returns (SetMessageFee memory smf);\r\n\r\n    function parseTransferFees(\r\n        bytes memory encodedTransferFees\r\n    ) external pure returns (TransferFees memory tf);\r\n\r\n    function parseRecoverChainId(\r\n        bytes memory encodedRecoverChainId\r\n    ) external pure returns (RecoverChainId memory rci);\r\n\r\n    function submitContractUpgrade(bytes memory _vm) external;\r\n\r\n    function submitSetMessageFee(bytes memory _vm) external;\r\n\r\n    function submitNewGuardianSet(bytes memory _vm) external;\r\n\r\n    function submitTransferFees(bytes memory _vm) external;\r\n\r\n    function submitRecoverChainId(bytes memory _vm) external;\r\n}\r\n"}},"settings":{"remappings":[],"optimizer":{"enabled":false,"runs":200},"evmVersion":"london"}}